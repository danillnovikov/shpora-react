import React from 'react';
import { Layout } from 'antd';
import './VirtualDOM.css';

const { Content } = Layout;

const VirtualDOM = () => {
  return (
    <Layout className="layout">
      <Content style={{ padding: '0 87px' }}>
        <div className="site-layout-content">
          <h1 className="title">Virtual DOM</h1>
          <p className="component_text">
            Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с
            его легковесной копией. Мы можем вносить изменения в копию, исходя
            из наших потребностей, а после этого применять изменения к реальному
            DOM. При этом происходит сравнение DOM-дерева с его виртуальной
            копией, определяется разница и запускается перерисовка того, что
            было изменено.
          </p>
          <p className="component_text">
            Такой подход работает быстрее, потому как не включает в себя все
            тяжеловесные части реального DOM. Но только если мы делаем это
            правильно. Есть две проблемы: когда именно делать повторную
            перерисовку DOM и как это сделать эффективно.
          </p>
          <h2 className="subtitle">Когда?</h2>
          <p className="component_text">
            Когда данные изменяются и нуждается в обновлении. Есть два варианта
            узнать, что данные изменились:
          </p>
          <ul className="component_text">
            <li>
              Первый из них — «dirty checking» (грязная проверка) заключается в
              том, чтобы опрашивать данные через регулярные промежутки времени и
              рекурсивно проверять все значения в структуре данных.
            </li>
            <li>
              Второй вариант — «observable» (наблюдаемый) заключается в
              наблюдении за изменением состояния. Если ничего не изменилось, мы
              ничего не делаем. Если изменилось, мы точно знаем, что нужно
              обновить.
            </li>
          </ul>
          <h2 className="subtitle">Как?</h2>
          <p className="component_text">
            Что делает этот подход действительно быстрым:
          </p>
          <ul className="component_text">
            <li>Эффективные алгоритмы сравнения</li>
            <li>Группировка операций чтения/записи при работе с DOM</li>
            <li>Эффективное обновление только под-деревьев</li>
          </ul>
        </div>
      </Content>
    </Layout>
  );
};

export default VirtualDOM;
